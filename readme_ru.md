# Damn Script
Это язык программирования созданный под вдохновением от .bat/.sh. Предназначен
для написания сценариев и игровой логики отдельных объектов.  
Код разбивается на "регионы", каждый из которых выполняется параллельно со всеми отстальными,
что позволяет обрабатывать за один кадр множество объектов, независимых друг от друга.
Помимо этого в языке есть возможность сохранения состояния для реализации сохранений и загрузок.
Язык является нетипизируемым и компилируемым в байткод для виртуальной машины.
Имеется возможность компиляции в реальном времени при парсинге файлов, либо компиляции в файл, содержащий байткод, что 
сильно ускоряет загрузку и экономит использование памяти.

## Теория
### Байткод
При компилировании скрипта, он преобразуется в низкоуровневый байткод, который затем исполняется виртуальной машиной.
Байткод представляет собой последовательность инструкций, каждая из которых выполняет какое-то действие (опкоды). Каждый
опкод имеет следующий формат:
```
[4 байта - идентификатор инструкции] ?[x байт - данные для инструкции] | [4 байта - идентификатор инструкции]...
```
Идентификатор служит для определения типа опкода и имеет фиксированный размер в 4 байта. За ним может как идти следующий
опкод, так и располагаться данные для инструкции. Данные могут быть какими угодно, в зависимости от инструкции.
Размер определяется структурой опкода, которые можно найти в исходной коде `Runtimes/VirtualMachines/OpCodes`.  
Благодаря опкодам можно прыгнуть в нужный участок кода, загрузить данные на стек, или сделать вызов функции.

### ScriptValue
Для хранения данных во время выполнения скрипта используется структура `ScriptValue`. Она представляет собой структуру
размером 12 байт следующего вида:
```
[4 байта - тип данных] [8 байт - сами данные]
```
Операции должны проводиться с данными не превышающими 8 байт! В любом ином случае данные будут обрезаны. Во избежание
этого операции со структурами длинне 8 байт должны либо быть разбиты на несколько операций, либо использоваться
указатели.
Допустимые типы данных:
- Invalid - тип данных который сигнализирует, что значение было инициализировано некооректно и не может быть обработано.
- Primitive - примитивный тип данных. Это может быть bool, int, float, double, char и др. Их размер все равно будет 8 байт.
- Pointer - указатель на данные. В данном случае значение может находиться где угодно в памяти, и его размер не фиксирован.
- ReferenceUnsafePointer - указатель на ссылочный тип данных. Не рекомендуется к использованию в .NET, если операция может
выполняться более одного кадра, так как возникает вероятность перемещания объекта GC и инвалидации указателя. Однако его
использование оправдано, но должно тщательно контролироваться!
- ReferenceSafePointer - указатель на ссылочный тип данных. В отличие от предыдущего, этот указатель безопасен для
использования, так как использует механизм закрепления объекта в памяти. Такой способ рекомендуется, если это возможно.  

Помимо этого `ScriptValue` имеет встроенные методы для математических операций, сравнения и битовых операций. Но будьте
осторожны, так как они не проверяют тип данных и могут привести к ошибкам, если внутри ScriptValue хранится указатель!

### Поток
В реалиях DamnScript поток - это независимая единица, которая в данные момент выполняет определенный регион кода.
После выполнения последнего опкода, он будет остановлен и удален из списка потоков.
За один вызов `ExecuteNext()` поток будет выполнять столько опкодов подряд, пока не выполнит все, либо не встанет
в состояние ожидания. В это состояние поток переходит при начале выполнения асинхронного метода. В этом случае вызов
`ExecuteNext()` будет совершать проверку, выполнена ли операция. Если нет - ничего не произойдет. В ином случае поток
возобновит свою работу, как это описано выше.  
Каждый поток имеет внутри себя 128 байт выделенных под стек.

### Стек
Для правильной работы кода необходимо по время выполнения сохранять значения и данные. Для этого у каждого потока есть
свой личный стек, размер которого фиксирован и является 128 байт. При переполнении стека будет вызывано исключение.
Стек используется для хранения локальных данных и для передачи аргументов в методы C#.  
Очень важно содержать стек в чистоте, так как он не очищается автоматически. Если C# метод что-то кладет на стек,
то другой метод должен использовать эти данные. В противном случае, стек будет засорен и возможно вызовет исключение!

### Вызов C# методов
Во время выполнения скрипта возможно вызывать методы C#. В метод может быть передано до 10 аргументов (до 9 в случае не
статического метода, так как один из аргументов будет использован для передачи указателя на вызываемый объект). Этот
метод так же должен оперировать только `ScriptValue`. Помимо аргументов, поддерживается возвращаемое значение, которое,
после выполнения метода, будет загружено на стек того потока, из которого был совершен вызов. Так же поддерживаются
возвращаемые значения для асинхронных методов при использовании `Task<ScriptValue>`.
Пример метода:
```csharp
public static ScriptValue AddAndPrint(ScriptValue first, ScriptValue second)
{
    var a = first.intValue;
    var b = second.intValue;
    var result = a + b;
    Console.WriteLine(result);
    return new ScriptValue(result);
}
```
В данном случае метод принимает два аргумента, складывает их и выводит результат в консоль. После этого возвращает
результат сложения, который будет записан на стек. 

### Строки
DamnScript поддерживается строки. Однако они не хранятся напрямую в ScriptValue, или байткоде. Во время компиляции,
когда компилятор находит строку, он вычисляет ее хэш и сохраняет в таблицу строк. В байткоде вместо строки будет
храниться хэш, по которому, во время выполнения, будет получен указатель на строку.
При использовании строки внутри скрипта DamnScript, как показано в примере:
```
PlaySound("OnWaypoint1");
```
Будет использована структура `UnsafeString`. Ничего опасного в ней нет, она находится в неуправляемой памяти и не
подвержена сборке мусора. Она полностью подготовлена к использованию и легко конвертируется в System.String (но в таком
случае будет аллокация System.String, как копия UnsafeString) для использования в высокоуровневом коде.
Помимо этого, при передаче строки из C# метода в скрипт, она должна быть обернута в `ScriptValue` и либо закреплена, либо
получен указатель на нее, так как является ссылочным типом!  
Помимо этого, если будет встречен дубликат строки (даже в другом скрипте, никак не связанным с этим), то копирования
данных не будет. Для обоих случаев будет использован один и тот же указатель на строку.

### Ассемблер
Любой код DamnScript компилируется в байткод, который легко можно представить в виде текста (ассемблера).
Выглядит это примерно так:
```
PUSH 1
PUSH 2
CALL AddAndPrint 2
```
Каждая строка представляет собой одну инструкцию. Первое слово - это идентификатор инструкции, а после него идут данные.   
Результатом такого кода будет:
- Загрузка на стек числа 1
- Загрузка на стек числа 2
- Вызов метода `AddAndPrint` с двумя аргументами

Это простой пример, но в реальности байткод может быть гораздо сложнее.  
Список поддерживаемых опкодов:
- CALL x, y (Native call) - вызвать метод C#. x - имя метода, y - количество аргументов.
- PUSH x (Push to stack) - загрузить константное выражение в стек. x - значение.
- EXPCALL x (Expression call) - вызов встроенного выражения, такого как сложение, вычитание и т.д. x - идентификатор 
(подробнее они перечислены в `ExpressionCall.ExpressionCallType`)
- SAVE (Save) - создает точку сохранения для последующей загрузки.
- JNE x (Jump not equal) - прыгнуть на указанный адрес, если два последних значения на стеке не равны. x - абсолютное
смещение в байктоде, относительно начала.
- JEQ x (Jump equal) - прыгнуть на указанный адрес, если два последних значения на стеке равны. x - абсолютное
смещение в байктоде, относительно начала.
- JMP x (Jump) - прыгнуть на указанный адрес. x - абсолютное смещение в байктоде, относительно начала.
- PUSHSTR x (Push string) - загрузить строку в стек. x - хэш строки в таблице строк.
## Синтаксис языка
```
region Main {
    GoToWaypointAsync(GetActor(), "Way1");
    PlaySound("OnWaypoint1");
    GoToWaypoint(GetActor(), "Way2");
    PlaySound("Shot");
    Die();
    
    if (IsDead(GetActor()) {
        Print("Actor is dead");
    }
    elseif (IsAlive(GetActor()) {
        Print("Actor is alive");
    }
    else {
        Print("HOW?!");
    }
}
```
Разберем этот пример:  
- region - ключевое слово для объявления региона. Как уже говорилось, код разбивается на регионы.
- Main - имя региона. В данном случае это главный регион, который будет выполнен по стандарту, если нет других указаний.
- { } - блок кода. Все что находится внутри фигурных скобок будет выполнено в рамках региона.
- GetActor() - вызов метода C#. В данном случае это метод без аргументов.
- "Way1" - строка.
- GoToWaypointAsync - вызов метода C#. В данном случае это асинхронный метод, на время выполнения которого поток будет
переведен в режим ожидания. Этот метод будет вызван после всех остальных в этой строки, так как остальные методы являются
аргументами.
- PlaySound - вызов метода C#. По логике псевдокода, этот метод будет вызван после завершения того, как Актер дойдет до
точки "Way1".
- GoToWaypoint - вызов метода C#. По логике псевдокода, этот метод будет вызван после того, как звук "OnWaypoint1" будет
воспроизведен.
- PlaySound - вызов метода C#. По логике псевдокода, этот метод будет вызван после того, как Актер дойдет до точки "Way2".
- Die - вызов метода C#. По логике псевдокода, этот метод будет вызван после того, как звук "Shot" будет воспроизведен.
- Далее следует привычное условие в C стиле. В данном случае проверяется, жив ли Актер. В зависимости от результата
выполняется один из блоков кода. Условия поддерживают операторы `&&`, `||`, `==`, `!=`, `>`, `<`, `>=`, `<=`, а так же
вызов методов C# в качестве условия.

Каждое выражение должно заканчиваться точкой с запятой `;` (в исключение входят условия и циклы).  
Следом, после уже объявленного региона, может быть объявлен новый, без ограничений. Каждый регион должен иметь уникальное
имя, не превышающее 32 символа!

## API
99% функционала реализовано без использования GC аллокаций. Из-за этого все взаимодействие с API будет происходить по
средствам указателей (предусмотрена работа и в безопасном режиме через ключевое слово ref). В качестве строк есть
возможность использовать как `System.String`, так и `UnsafeString`, однако для высокоуровневого кода предпочтительнее все
же использовать `System.String`, так как `UnsafeString` не реализует все методы строки, а так же требует ручного
освобождения памяти.

### Инициализация
DamnScript не требует дополнительной специальной инициализации. Для начала работы достаточно загрузить скрипт в память и
создать для него поток. Сделать это можно так:
```csharp
var fileStream = File.Open("Test1.ds", FileMode.Open);
var scriptData = ScriptEngine.LoadScript(fileStream, "Test1");
var thread = ScriptEngine.RunThread(scriptData);
```
Теперь разберем по шагам:
1. Для начала мы открываем стрим на файл, содержащий скрипт. Это может быть любой стрим, который наследуется от `Stream`.
2. Загружаем скрипт в память. Первый аргумент - это стрим, второй - имя скрипта. Имя скрипта должно быть уникальным и не
превышать 32 символов.
3. Создаем поток для скрипта на виртуальной машине, который начнет исполнение региона `Main`, так как иное не указано.

После создания потока он НЕ начинает работу автоматически. Каждый игровой кадр (или в любой другой момент) необходимо
вызывать метод `ScriptEngine.ExecuteNext()`. Этот метод будет обрабатывать каждый поток, который был создан и в данный
момент не закончил свою работу. Это должно работать таким образом:
```csharp
while (ScriptEngine.ExecuteNext())
    Thread.Sleep(15);
```
`ScriptEngine.ExecuteNext()` возвращает `true`, если есть потоки, которые еще не завершили свою работу. В ином случае
вернет `false`. Для нашей программы это значит, что пора закончить свою работу, в вашем случае логика может быть более
сложной.
Если вам нужно остановить выполнение потока, это можно сделать, вызвав `Dispose()` метод у потока.
В случае, если после выполнения скрипта ваша программа должна продолжить работу, вам может понадобиться выгрузить скрипт
из памяти. В таком случае это можно сделать через метод `ScriptEngine.UnloadScript()`. Важно! Не выгружайте скрипт, если
поток с этим скриптом все еще работает! Это может привести к непредсказуемым результатам!

## Roadmap
- [x] Базовый функционал
- [x] Возможность вызова методов C#
- [x] Условия (if, elseif, else)
- [ ] Циклы (for, while)
- [ ] Поддержка Unity
- [ ] Дополнительные средства безопасности
- [ ] Сохранение состояния
- [ ] Загрузка состояния
- [ ] Выгрузка неиспользуемых метаданных
- [ ] Дополнительные проверки безопасного управления памятью
- [ ] Мягкая миграция при изменении байткода
- [ ] Hot-reload

... И многое другое. :)

## Поддержка
Вы так же можете поддержать проект, купив мне кофе, чтобы я и дальше, ночи на пролет, мог развивать этот проект.
[![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/rietmon)